[![返回目录](https://parg.co/Udx)](https://parg.co/UdT)

# MicroService( 微服务 )

微服务架构模式(Microservices Architecture Pattern )的目的是将大型的、复杂的、长期运行的应用程序构建为一组相互配合的服务，每个服务都可以很容易得局部改良。Micro 这个词意味着每个服务都应该足够小，但是，这里的小不能用代码量来比较，而应该是从业务逻辑上比较 —— 符合 SRP 原则的才叫微服务。微服务可以认为是 SOA 的一种实现方案，去除了 ESB 的 SOA。ESB 是 SOA 架构中的中心总线，设计图形应该是星形的，而微服务是去中心化的分布式软件架构。

微服务架构是Martin Fowler 在2014年提出的架构模式(如图1)，微服务架构有如下特点：按照业务领域拆分服务、一系列小服务构成、服务独立部署、独立运行、服务间去中心化管理

微服务首先按照业务领域模型垂直拆分，即根据不同的业务功能单元进行垂直拆分。对垂直拆分后的服务，在水平方向继续进行拆分。

根据 Oracle 大神的指导，MicroService 可以认为是 SOA 的一种实现方案：

> Microservices are the kind of SOA we have been talking about for the last decade. Microservices must be independently deployable, whereas SOA services are often implemented in deployment monoliths. Classic SOA is more platform driven, so microservices offer more choices in all dimensions.

**1. 优点**

* 每个服务足够内聚，足够小，代码容易理解、开发效率提高
* 服务之间可以独立部署，微服务架构让持续部署成为可能；
* 每个服务可以各自进行 x 扩展和 z 扩展，而且，每个服务可以根据自己的需要部署到合适的硬件服务器上；
* 容易扩大开发团队，可以针对每个服务(service )组件开发团队；
* 提高容错性(fault isolation )，一个服务的内存泄露并不会让整个系统瘫痪；
* 系统不会被长期限制在某个技术栈上。

**2. 缺点**

《人月神话》中讲到：没有银弹，意思是只靠一把锤子是盖不起摩天大楼的，要根据业务场景选择设计思路和实现工具。我们看下为了换回上面提到的好处，我们付出(trade )了什么？

* 开发人员要处理分布式系统的复杂性；开发人员要设计服务之间的通信机制，对于需要多个后端服务的 user case，要在没有分布式事务的情况下实现代码非常困难；涉及多个服务直接的自动化测试也具备相当的挑战性；
* 服务管理的复杂性，在生产环境中要管理多个不同的服务的实例，这意味着开发团队需要全局统筹(_PS ：现在 docker 的出现适合解决这个问题_)
* 应用微服务架构的时机如何把握？对于业务还没有理清楚、业务数据和处理能力还没有开始爆发式增长之前的创业公司，不需要考虑微服务架构模式，这时候最重要的是快速开发、快速部署、快速试错。

# 巨石 (monolith)应用的演化

在 Web 应用程序发展的早期，大部分 web 工程是将所有的功能模块(service side )打包到一起并放在一个 web 容器中运行，很多企业的 Java 应用程序打包为 war 包。其他语言(Ruby ， Python 或者 C++)写的程序也有类似的问题。譬如对于一个最简单的电商系统，可能会形成如下的架构：

![](http://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RA4LTYdW8vIiaBFNyKAP0khnnroHVqgaicN0dpkyrDsZoASF716LHE6OSv0KgykUc3T5ia1YhcEJJuVA/640?wx_fmt=png&wxfrom=5&wx_lazy=1)

这种将所有功能都部署在一个 web 容器中运行的系统就叫做巨石型应用。巨石型应用有很多好处：IDE 都是为开发单个应用设计的、容易测试 —— 在本地就可以启动完整的系统、容易部署 —— 直接打包为一个完整的包，拷贝到 web 容器的某个目录下即可运行。

但是，上述的好处是有条件的：应用不那么复杂。对于大规模的复杂应用，巨石型应用会显得特别笨重：要修改一个地方就要将整个应用全部部署(_PS ：在不同的场景下优势也变成了劣势_)；编译时间过长；回归测试周期过长；开发效率降低等。另外，巨石应用不利于更新技术框架，除非你愿意将系统全部重写(代价太高你愿意老板也不愿意)。

单体架构是指业务功能的实现全部在一个进程(process)内完成。单体架构的优点第一请求响应延迟低，接收客户端请求，经过一次网络交互从数据库批量获取数据，其余的功能全部在进程内完成，避免了多次的网络交互。第二仅一个进程，部署和运维成本小。

创业初期，人手紧张，又需要快速完成业务需求。第二是对性能要求极其苛刻场景，哪怕请求慢1ms都无法接受(比如在金融行业，量化交易场景，响应时间就是生命线)。

单体架构最大的问题是架构粒度过粗，导致系统迭代速度快不起来。互联网业务又是持续高速发展的业务，采用单体架构很难满足需求，系统架构如何演进？单体架构需要按照某些维度进行拆分：按照系统水平方向进行拆分(水平分层架构)、按照业务功能垂直拆分(SOA架构)、既按照业务功能垂直拆分又按照系统水平方向进行拆分(微服务

【水平分层架构(Horizontal layered Architecture)】

网关层接收客户端请求，对请求合法性校验以及鉴权、对请求根据URI路由转发到相应的业务逻辑层；业务逻辑层负责请求具体的业务逻辑处理，在微信端发送消息给好友，业务逻辑层会对发送消息进行黄反等策略检查、会校验发送者的权限(你遇到过“消息已发送，被对方拒收”的情况吗？)、判断接收方是否在线等等。业务逻辑层不会直接和数据库交互，它需要的数据通过数据访问层获取。数据访问层有三部分功能构成：第一是ORM，接收业务逻辑层发送的数据协议(JSON等文本协议或者PB等二进制协议)转换成SQL协议；第二是Sharding，数据库存储数据超过千万级别时，为了进一步提升性能，会按照业务功能垂直拆分库以及水平方向拆分表。因此在此层提供分库分表支持，对业务逻辑层透明，使之无感知。第三是随着业务请求量继续增大，Sharding后依然无法满足性能需求，进一步增加Cache功能，对业务逻辑层透明。存储层往往使用MySQL提供关系存储，使用Redis提供缓存。

水平分层架构解决了单体架构的问题，它存在明显问题是每层粒度过粗，在每一层并没有按照业务功能单元进一步垂直拆分。

# 应用拆分

![](http://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RA4LTYdW8vIiaBFNyKAP0khnKvib5CIjF3ibc9ytWgB6Z6Ggo9d4D2aarWJQEiauicBBffEtlMI44yzIfw/640?wx_fmt=png&wxfrom=5&wx_lazy=1)

这张图从三个维度概括了一个系统的扩展过程：( 1)x 轴，水平复制，即在负载均衡服务器后增加多个 web 服务器；( 2)z 轴扩展，是对数据库的扩展，即分库分表(分库是将关系紧密的表放在一台数据库服务器上，分表是因为一张表的数据太多，需要将一张表的数据通过 hash 放在不同的数据库服务器上)；(3 ) y 轴扩展，是功能分解，将不同职能的模块分成不同的服务。从 y 轴这个方向扩展，才能将巨型应用分解为一组不同的服务，例如订单管理中心、客户信息管理中心、商品管理中心等等。

将系统划分为不同的服务有很多方法：( 1)按照用例划分，例如在线商店系统中会划分出一个 checkout UI 服务，这个服务实现了 checkout 这个用例；( 2)按照资源划分，例如可以划分出一个 catlog 服务来存储产品目录。

服务划分有两个原则要遵循：( 1)每个服务应该尽可能符合单一职责原则 ——Single Responsible Principle，即每个服务只做一件事，并把这件事做好；( 2)参考 Unix 命令行工具的设计，Unix 提供了大量的简单易用的工具，例如 grep、cat 和 find。每个工具都小而美。

最后还要强调：系统分解的目标并不仅仅是搞出一堆很小的服务，这不是目标；真正的目标是解决巨石型应用在业务急剧增长时遇到的问题。

对于上面的例子，按照功能和资源划分后，就形成下面图 3 的架构图。分解后的微服务架构包含多个前端服务和后端服务。前端服务包括 Catalog UI(用于商品搜索和浏览)、 Checkout UI(用于实现购物车和下单操作)；后端服务包括一些业务逻辑模块，我们将在巨石应用中的每个服务模块重构为一个单独的服务。这么做有什么问题呢？

![](http://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RA4LTYdW8vIiaBFNyKAP0khnWXC4ic9Awg5hWwrs0lzqvX7qibm2riaxQCsmfZ0zreu1jV57Ds7Wwju3A/640?wx_fmt=png&wxfrom=5&wx_lazy=1)

# 微服务之间的通信

> [新瓶装旧酒？从微服务同步 REST 的天然缺陷说起](http://blog.dataman-inc.com/115-shurenyun-rest/)

**(1 )客户端与服务器之间的通信**

在巨石型架构下，客户端应用程序(web 或者 app)通过向服务端发送 HTTP 请求；但是，在微服务架构下，原来的巨石型服务器被一组微服务替代，这种情况下客户端如何发起请求呢？

如图 4 中所示，客户端可以向 micro service 发起 RESTful HTTP 请求，但是会有这种情况发生：客户端为了完成一个业务逻辑，需要发起多个 HTTP 请求，从而造成系统的吞吐率下降，再加上无线网络的延迟高，会严重影响客户端的用户体验。

![](http://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RA4LTYdW8vIiaBFNyKAP0khneb6U1PnJkcwcOC4lKTQcoOcibszIxOHjyDvysLMkWnyDAAeGicGicELfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1)

Fig4 - calling services directly

为了解决这个问题，一般会在服务器集群前面再加一个角色：API gateway ，由它负责与客户度对接，并将客户端的请求转化成对内部服务的一系列调用。这样做还有个好处是，服务升级不会影响到客户端，只需要修改 API gateway 即可。加了 API gateway 之后的系统架构图如图 5 所示。

![](http://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RA4LTYdW8vIiaBFNyKAP0khnevaeY61h6sciaW9IRF6pPClhkGNiaQCOqRq6zzjSQ07MZVcmA7W1HiakA/640?wx_fmt=png&wxfrom=5&wx_lazy=1)

Fig5 - API gateway

**( 2)内部服务之间的通信**

内部服务之间的通信方式有两种：基于 HTTP 协议的同步机制(REST 、 RPC)；基于消息队列的异步消息处理机制(AMQP-based message broker )。

Dubbo 是阿里巴巴开源的分布式服务框架，属于同步调用，当一个系统的服务太多时，需要一个注册中心来处理**服务发现**问题，例如使用 ZooKeeper 这类配置服务器进行服务的地址管理：服务的发布者要向 ZooKeeper 发送请求，将自己的服务地址和函数名称等信息记录在案；服务的调用者要知道服务的相关信息，具体的机器地址在 ZooKeeper 查询得到。这种同步的调用机制足够直观简单，只是没有 “ 订阅 —— 推送 ” 机制。

AMQP-based 的代表系统是 kafka、RabbitMQ 等。这类分布式消息处理系统将订阅者和消费者解耦合，消息的生产者不需要消费者一直在线；消息的生产者只需要把消息发送给消息代理，因此也不需要服务发现机制。

两种通信机制都有各自的优点和缺点，实际中的系统经常包含两种通信机制。例如，在分布式数据管理中，就需要同时用到同步 HTTP 机制和异步消息处理机制。

**2. 分布式数据管理**

**(1 )处理读请求**

在线商店的客户账户有限额，当客户试图下单时，系统必须判断总的订单金额是否超过他的信用卡额度。信用卡额度由 CustomerService 管理、下订单的操作由 OrderService 负责，因此 Order Service 要通过 RPC 调用向 Customer Service 请求数据；这种方法能够保证每次 Order Service 都获取到准确的额度，单缺点是多一次 RPC 调用、而且 Customer Service 必须保持在线。

还有一种处理方式是，在 OrderService 这边存放一份信用卡额度的副本，这样就不需要实时发起 RPC 请求，但是还需要一种机制保证 —— 当 Customer Service 拥有的信用卡额度发生变化时，要及时更新存放在 Order Service 这边的副本。

**( 2)处理更新请求**

当一份数据位于多个服务上时，必须保证数据的一致性。

* 分布式事务(Distributed transactions )

  使用分布式事务非常直观，即要更新 Customer Service 上的信用卡额度，就必须同时更新其他服务上的副本，这些操作要么全做要么全不做。使用分布式事务能够保证数据的强一致，但是会降低系统的可用性 —— 所有相关的服务必须始终在线；而且，很多现代的技术栈并不支持事务，例如 REST、NoSQL 数据库等。

* 基于事件的异步更新(Event-driven asynchronous updates )

  Customer Service 中的信用卡额度改变时，它对外发布一个事件到 “message broker(消息代理人)” ；其他订阅了这个事件的服务受到提示后就更新数据。事件流如图 6 所示。

  ![](http://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RA4LTYdW8vIiaBFNyKAP0khnfsbdEH4nNZ4iapSQ1HKsbJKDkLuOtp7ib5rSDRGjz16H9wBpWumjbZwA/640?wx_fmt=png&wxfrom=5&wx_lazy=1)

微服务本身代表了一种软件交付以及复用模式的变化，从依赖库到依赖服务，和 SOA 有相通之处。

1. 部署单元的粒度越来越小，加快交付效率，同时增加运维的复杂度。
2. 依赖方式从依赖库到依赖服务，增加了开发者选择的自由(语言、框架、库)，提高了复用效率，同时增加了治理的复杂度。
3. 架构模式从单体应用到微服务架构，架构设计的关注点从分层转向了服务拆分。

【微服务涉及的技术点】

1. 服务注册与发现服务目录服务列表配置中心
2. 进程间通讯负载均衡
3. 服务生命周期管理部署、变更、升级、自动化运维
4. 服务依赖关系
5. 链路跟踪、限流、降级、熔断
6. 访问控制
7. 日志与监控
8. 微服务应用框架

互联网技术架构飞速演进，特别是底层硬件及芯片技术快速发展，后端服务器的能力越来越强大。多数情况下，单个业务已很难消耗完一整台服务器的资源或处理能力。移动互联网深度融合与应用，瘦客户端兴起，使得云端能力与承载变得更加重要。容器技术得到广泛认可与应用，轻量级协议、代码管理、新集成方法与工具等技术也越来越成熟。

![](https://parg.co/UZs)

# 微服务的设计理念

# 微服务的实践路线

## 渐进式架构

![](https://parg.co/U8h)

## 灵活的组织模式

前后端分离

# 设计模式

## Event Driven: 设计驱动

# 微服务的红与黑

## 开发与运维复杂度的增加

## 真实系统往往难以明确划分边界

## 状态管理与通信的复杂度

## 分布式事务与版本管理
